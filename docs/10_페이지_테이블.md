# 페이지 테이블

운영체제는 다양한 이유로 물리 주소를 직접 사용하지 않고 논리 주소(가상 주소)를 사용한다.

첫번째로 보안적 이점이 있다. 물리 주소를 직접 사용하게 되면 프로세스가 다른 프로세스나 심지어는 커널이 사용중인 메모리 주소에 접근할 수 있다.

두번째로 메모리 용량에서 이점이 있다. 논리 주소를 이용하면 가용 물리 메모리 용량보다 많은 메모리를 사용할 수 있다.

이때 논리 주소를 물리 주소로 변환하기 위해 사용되는 것이 페이지 테이블이다. 페이지 테이블은 아래와 같이 구성된다. 이떄 매핑된 인덱스들은 메모리 할당 단위인 페이지(일반적으로 4KB)의 인덱스이다. 페이지 테이블의 각 행을 페이지 엔트리라고 부른다.

| 논리 페이지 인덱스 | 물리 페이지 인덱스 |
|------------|------------|
| 0          | 2          |
| 1          | 8          |
| 2          | 10         |
...

만약 프로세스가 0x00001024 주소에 접근한다고 가정하자. 32bit 중 4KB(2^12)에 해당하는 부분인 024는 offset값으로, 그 앞의 00001은 페이지 인텍스로 사용된다. 페이지 테이블을 참조하면 1번 페이지는 물리 8번 페이지에 매핑되어 있으므로, 0x00008024 주소를 참조하게 된다.

이렇게 페이지 테이블을 1개만 사용할 경우 페이지 테이블의 용량 문제가 발생한다. 페이지는 일반적으로 4KB(2^12) 용량을 갖는다. 32비트 아키텍처에서 사용할 수 있는 주소는 4GB(2^32)가지이므로, 2^20(1M)개의 페이지 엔트리가 필요하다. 페이지 엔트리 1개 당 4Byte라고 계산하면 4GB의 메모리를 사용하기 위해 4MB 크기의 페이지 테이블이 필요하다.

페이지 테이블의 용량을 줄이기 위한 방법 중 하나로 다단계 페이지 테이블을 사용한다. 다단계 페이지 테이블은 접근 시간을 포기하는 대신 사용하지 않는 페이지에 대한 테이블을 제거하여 용량을 줄일 수 있다.

2개의 페이지 테이블을 사용하는 2단계 페이지 테이블에서 각 테이블의 페이지 엔트리 개수는 1KB(2^10)개로, 2단계를 거쳐 1KB * 1KB = 1M (2^10 * 2^10 = 2^20)개의 엔트리를 표현할 수 있다. 또한 엔트리 1개당 4KB이므로 4KB의 용량을 가져 1개의 페이지에 1개의 테이블을 저장할 수 있다.

마찬가지로 00001024 주소에 접근할 경우, 주소를 아래와 같이 사용한다. [RISC-V Sv-32 Virtual Address Breakdown](https://riscv-sv32-virtual-address.vercel.app/)을 참고하여 주소가 어떻게 쪼개지는지 확인할 수 있다.

|    | 1단계 테이블 인텍스  | 2단계 테이블 인덱스  | offset         |
|----|--------------|--------------|----------------|
| 0b | 0000 0000 00 | 00 0000 0001 | 0000 0010 0100 |
| 0x | ___0 ___0 __ | _0 ___0 ___1 | ___0 ___2 ___4 |

> Tip
> 주소의 변화를 관찰해보면 다음 2가지 사실을 알 수 있다.
> 1. 0-11번째 비트 변경시 테이블 인덱스는 변하지 않는다. (같은 물리 페이지를 참조한다.)
> 2. 12-21번째 비트 변경시 1단계 테이블 인덱스는 변하지 않는다. (같은 2단계 테이블을 참조한다.)
     > 공간 지역성을 활용하는 구조임을 알 수 있다. 논리 주소를 물리 주소로 변환할 때 참조 시간을 줄이기 위해 TLB(Transition Lookaside Buffer)을 사용해 캐싱하는데, 이와 같은 구조를 사용해 캐시 Hit rate을 높일 수 있다.

따라서 1단계 인덱스는 0, 2단계 인덱스는 1, offset은 24가 된다. 페이지 테이블이 아래와 같이 구성되어있다고 하면,
1. 1단계 테이블의 0번째 엔트리를 참조하여 2번째 2단계 테이블을 확인한다.
2. 2번째 2단계 테이블의 1번째 엔트리를 참조하여 8번째 물리 페이지를 확인한다.
3. 8번째 물리 페이지에서 offset이 24인, 즉 0x00008024 주소를 최종적으로 참조한다.

1단계 테이블:

| 1단계 테이블 인덱스 | 2단계 테이블 인덱스 |
|-------------|-------------|
| 0           | 2           |
| 1           | 8           |
| 2           | 10          |
...

2번째 2단계 테이블:

| 논리 페이지 인덱스 | 물리 페이지 인덱스 |
|------------|------------|
| 0          | 5          |
| 1          | 8          |
| 2          | 9          |
...

만약 프로세스가 4GB의 메모리를 전부 사용한다면 1KB(2^12)개의 2단계 테이블과 1개의 1단계 테이블이 필요하므로 용량은 4MB + 4KB가 된다. 하지만 사용하지 않는 메모리가 있다면 그 부분에 해당하는 2단계 테이블을 생성하지 않으므로 그만큼의 메모리를 줄일 수 있다. 예를 들어 메모리를 2GB만 사용한다면 0.5KB개의 2단계 테이블과 1개의 1단계 테이블만 있으면 되므로 페이지 테이블이 차지하는 용량이 절반가량 줄어든다.

1단계 테이블은 항상 4KB의 용량을 차지하고, 모든 2단계 테이블에 대한 엔트리를 갖고 있다. 단, 존재하지 않는 2단계 테이블에 대한 엔트리의 경우 null값을 저장한다. 이렇게 구성하는 이유는 페이지 테이블의 엔트리에 접근할 때 배열을 사용하여 시간 복잡도를 O(1)로 만들기 위함이다.

`kernel.c`에 작성한 아래 `map_page`함수는 1단계 테이블, 논리주소 및 물리주소, 권한 설정을 위한 플래그를 받아 페이지 테이블을 생성하고 주소를 매핑해주는 함수이다. 사용된 매크로는 `kernel.h`에 있다.

```c
// kernel.h
// 이후 페이지 테이블을 활성화하기 위해 레지스터에 값을 넣을 때 설정해야하는 비트이다. 해당 비트가 1로 설정되어 있어야 Sv32 모드로 페이징을 할 수 있다.
#define SATP_SV32 (1u << 31)
// 아래 매크로는 페이지 권한 설정을 위한 비트이다.
#define PAGE_V    (1 << 0)
#define PAGE_R    (1 << 1)
#define PAGE_W    (1 << 2)
#define PAGE_X    (1 << 3)
#define PAGE_U    (1 << 4)

// kernel.c
void map_page(uint32_t* table1, vaddr_t vaddr, paddr_t paddr, uint32_t flags) {
    // 논리 주소 또는 물리 주소가 페이지의 시작점을 가르키고 있지 않을 경우 패닉을 일으킨다.
    if (!is_aligned(vaddr, PAGE_SIZE))
        PANIC("unaligned vaddr %x\n", vaddr);
    
    if (!is_aligned(paddr, PAGE_SIZE))
        PANIC("unaligned paddr %x\n", paddr);
    
    // 1단계 테이블에서 조회할 엔트리의 인덱스를 계산한다.
    uint32_t vpn1 = (vaddr >> 22) & 0x3FF;
    // 해당 엔트리가 가르키고 있는 2단계 테이블이 없을 경우, 2단계 테이블을 새로 만든다.
    // PAGE_V는 Validation Bit로, 주소 0과 NULL을 구분하기 위해 사용한다.
    if ((table1[vpn1] & PAGE_V) == 0) {
        paddr_t table2_page_addr = alloc_pages(1);
        // 페이지 크기로 나누는 이유는 실제 페이지 주소가 아니라 몇번째 페이지인지를 저장해야하기 때문이다.
        // 이후 Validation Bit 설정을 위해 시프트하고 엔트리에 해당 값을 저장한다.
        table1[vpn1] = ((table2_page_addr / PAGE_SIZE) << 10) | PAGE_V;
    }

    // 2단계 테이블 주소를 계산한다.
    paddr_t* table2 = (paddr_t*) ((table1[vpn1] >> 10) * PAGE_SIZE);
    // 2단계 테이블에서 조회할 엔트리의 인덱스를 계산한다.
    uint32_t vpn2 = (vaddr >> 12) & 0x3FF;
    // 마찬가지로 물리 주소를 페이지 크기로 나누고 플래그를 넣어준다.
    table2[vpn2] = ((paddr / PAGE_SIZE) << 10) | PAGE_V | flags;
}
```

다음으로는 프로세스 생성시 커널 메모리 영역을 페이지 테이블에 넣어주어야 한다. 여기서는 페이징을 활성화시킨 후에도 코드가 똑같이 동작할 수 있도록 커널 메모리 영역의 논리 주소와 물리 주소를 일치시킨다. 커널 메모리 영역은 메모리 시작점부터 `__free_ram_end`까지이다. 메모리 시작점을 가져오기 위해 링커 스크립트에 `__kernel_base` 변수를 선언해주자.

```linkerscript
ENTRY(boot)

SECTIONS {
    . = 0x80200000;
    __kernel_base = .;
     /* 생략 */
```

이후 `kernel.h`에 정의된 PCB 구조체에 `page_table` 속성을 추가하고 `kernel.c`에 정의된 `create_process` 함수를 아래와 같이 수정해주자.
```c
// 링커 스크립트에서 __kernel_base를 가져온다.
extern char __kernel_base[];

struct process* create_process(uint32_t entry_point) {
    // 생략
    
    // 페이지 테이블을 저장할 페이지를 생성한다.
    paddr_t page_table = alloc_pages(1);
    for (
        // 커널 메모리 시작점 ~ 끝점까지
        paddr_t addr = (paddr_t)__kernel_base;
        addr < (paddr_t)__free_ram_end;
        addr += PAGE_SIZE
    ) {
        // 페이지를 생성하고 매핑한다.
        paddr_t page = alloc_pages(1);
        map_page(
            (uint32_t *)page_table,
            addr,
            addr,
            PAGE_R | PAGE_W | PAGE_X
        );
    }

    proc->pid = i;
    proc->state = PROC_RUNNABLE;
    proc->sp = (uint32_t) sp;
    
    // PCB에 페이지 테이블 주소값을 저장한다.
    proc->page_table = page_table;
    
    return proc;
}
```

마지막으로 컨텍스트 스위칭 시 페이지 테이블을 설정해준다.

```c
void yield() {
    // 생략

    __asm__ __volatile__ ("sfence.vma");
    WRITE_CSR(satp, (SATP_SV32 | ((uint32_t) next_proc->page_table / PAGE_SIZE)));
    __asm__ __volatile__ ("sfence.vma");
    
    WRITE_CSR(sscratch, (uint32_t) &next_proc->stack[sizeof(next_proc->stack)]);

    struct process* prev_proc = current_proc;
    current_proc = next_proc;
    switch_context(&prev_proc->sp, &next_proc->sp);
}
```
`sfence.vma`는 supervisor fence virtual memory adress라는 뜻으로, CPU의 메모리 접근을 제어하는 MMU의 캐시를 지워버린다. 캐시를 지우는 이유는 캐싱 시 사용될 주소를 미리 예측할 수 있기 때문이다. 만약 캐시를 지우지 않았다면 캐시 미스가 일어나고 페이지 테이블을 참조하여 물리 주소를 읽어오는, 시간이 오래걸리는 작업을 해야한다. 캐시를 지움으로써 MMU가 미리 주소를 캐싱하게 되고, 결과적으로 성능을 향상시킬 수 있다.

참고: https://blog.stephenmarz.com/2021/02/01/wrong-about-sfence/

실행해보면 이전과 똑같은 출력이 나온다. 페이지 테이블이 정상적으로 설정되었는지 확인하려면 QEMU의 디버깅 기능을 이용하면 된다. `ctrl+c, a`를 눌러 디버깅 모드에 진입하고, `info mem`을 입력하면 아래와 같은 페이지 테이블을 확인할 수 있다.

```shell
(qemu) info mem
vaddr    paddr            size     attr
-------- ---------------- -------- -------
80200000 0000000080200000 00001000 rwx--ad
80201000 0000000080201000 00001000 rwx----
80202000 0000000080202000 00001000 rwx--a-
80203000 0000000080203000 00001000 rwx----
80204000 0000000080204000 00001000 rwx--ad
80205000 0000000080205000 00001000 rwx----
80206000 0000000080206000 00001000 rwx--ad
80207000 0000000080207000 00009000 rwx----
...
84000000 0000000084000000 00231000 rwx----
```

커널 메모리 영역 시작점인 `0x80200000`부터 매핑이 시작되어 논리주소와 물리주소가 일치하게 매핑되어있음을 확인할 수 있다.
